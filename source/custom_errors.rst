Registering custom error types
==============================

By default, ``friendly`` provides a set of traceback explanations for builtin exceptions.
However, it is also possible to add explanation texts for custom error types. For that,
two entry points are available. The first one is
:func:`@friendly_traceback.info_generic.register <friendly_traceback.info_generic.register>`
decorator that registers a generic message that describes an error type. Example:

.. code-block::

   from friendly_traceback import info_generic

   @info_generic.register(CustomError)
   def describe():
       return "CustomError is raised when ..."

:func:`@friendly_traceback.info_generic.register <friendly_traceback.info_generic.register>`
will accept any parameterless function that returns a string.

Use the second decorator
:func:`@friendly_traceback.info_specific.register <friendly_traceback.info_specific.register>`
to register a specific description for a particular error instance. Example:

.. code-block::

   from friendly_traceback import info_specific

   @info_specific.register(CustomError)
   def describe(error, frame, traceback_data):
       return {
           "cause": (
               f"The particular custom error was {error}, "
               f"raised in file {traceback_data.filename!r} "
               f"on line {traceback_data.program_stopped_bad_line!r}."
           )
       }

Notice that a function accepted by
:func:`@friendly_traceback.info_specific.register <friendly_traceback.info_specific.register>`
gets three input arguments: the raised exception instance, the current frame
and the traceback data object generated by ``friendly`` that provides great
help for eventual introspection. The function should return not a string
this time, but a dictionary with the custom description stored under ``"cause"``.
The dictionary may also contain a ``"suggest"`` key; in that case, a custom
suggestion for avoiding or mitigating the error will be displayed.

Example
^^^^^^^

Imagine we have a container ``api`` with a web service running behind
the address ``https://my-services/api``. The following snippet requests
data from the service:

.. code-block::

   import requests

   def fetch_data():
       response = requests.get("https://my-services/api")
       response.raise_for_status()
       return response.json()

   fetch_data()

When the connection can not be established, a :exc:`requests.ConnectionError` will be raised.
Fortunately, since it inherits from :exc:`OSError`, ``friendly`` is able to provide a hint
about the error cause:

  An exception of type ``ConnectionError`` is a subclass of ``OSError``. An ``OSError``
  exception is usually raised by the Operating System to indicate that an operation
  is not allowed or that a resource is not available.

  I suspect that you are trying to connect to a server and that a connection cannot be made.

  If that is the case, check for typos in the URL and check your internet connectivity.

What if we want to add a more detailed information? First, we can register a custom generic
description for any occurences of the :exc:`requests.ConnectionError`:

.. code-block::

   from friendly_traceback import info_generic

   @info_generic.register(requests.ConnectionError)
   def describe():
       return "It looks like the container `api` may be offline."

Now ``friendly`` will print

  It looks like the container ``api`` may be offline.

  I suspect that you are trying to connect to a server and that a connection cannot be made.

  If that is the case, check for typos in the URL and check your internet connectivity.

Second, we register a custom hook that generates a specific description for the particular error:

.. code-block::

   from friendly_traceback import info_specific

   suggest = """
   First, check whether the container is running:
   ```sh
   $ docker container inspect -f '{{.State.Running}}' api
   ```
   If necessary, restart with
   ```sh
   $ docker restart api
   ```"""

   @info_specific.register(requests.ConnectionError)
   def describe(error, frame, traceback_data):
       cause = (
           f"Reason: the {error.request.method} request "
           f"for `{error.request.url}` has failed."
       )
       return {"cause": cause, "suggest": suggest}

This results in the following customized ``friendly`` output:

  First, check whether the container is running:

  .. code-block:: sh

     $ docker container inspect -f '{{.State.Running}}' my-service

  If necessary, restart with

  .. code-block:: sh

     $ docker restart my-service

  It looks like the container ``api`` is offline.

  Reason: the GET request at ``https://my-services/api`` has failed.
